[
    {
        "name": "no_smells_01",
        "description": "Tracing with a random number of smells.",
        "group": "arkanoid",
        "game": "arkanoid",
        "code_language": "java",
        "iterations": 3,
        "llm": {
            "type": "GPT",
            "model": "gpt-4o",
            "temperature": 0
        },
        "prompts": [
            {
                "role": "system",
                "content": "You are a helpful assistant that generates a sequence diagram from the given requirements so that I can provide it to Planttext to\nvisualize it.\n\nInput: A list of game requirements. Each requirement will be labeled (e.g., 1., 2., etc.). Your task is to generate a PlantUML sequence diagram that:\n1. Represents the requirements in sequence diagram format.\n2. Includes sticky notes indicating which part of the diagram corresponds to each requirement. Each sticky note must follow this format: `note right of [Actor/Participant]: Rule [Number]`.\n3. You can use alt/end or alt/else/end blocks for conditional branching to visually represent alternative flows. Alt blocks can be nested.\n4. Some requirements may contain extra details (such as UI information, numerical data, component sizes or shapes) that are not directly related to system behavior or game mechanics. Append\nthese extra details as additional notes at the end of the diagram (just before the `@enduml` tag). Use newline with a new note component if there are too much information so that the diagram\ndoes not get too wide. Use the following syntax:\nnote right of <leftmost_participant/actor>: Rule <RuleID>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\n\nOutput: Only the JSON that containes the PlantUML sequence diagram. Do not add any explanations or comments.\n\nExample Input:\n1. The game is played by 2 players.\n2. In each turn, a player rolls a die. Then the other player rolls a die.\n3. The player who rolls a 6 gets 1 point.\n4. The player who rolls a 3 gets 2 points.\n5. If 2 players run the same die value, they both get 1 points. This rule overrules the rules about rolling 3 or 6.\n6. The player who reaches 10 points first, wins the game.\n7. A die is a classic white die which has values from 1 to 6.\n8. The game board has size 50 cm x 50 cm and it has borders that prevent dice to go out. The players roll the die into this board. If a die goes out, the roll is repeated. \n\nExample Output: Return a JSON object with the following structure:\n{\n  \"output\": \"@startuml\n<PlantUML diagram description that defines game mechanics comes here>\nnote right of Player: Rule 7\nnote right of Player: A die is a classic white die with values from 1 to 6\nnote right of Player: Rule 8\nnote right of Player: The game board has size 50 cm x 50 cm.\nnote right of Player: The players roll the dice into the game board.\nnote right of Player: Its borders prevent dice to go out.\n@enduml\"\n}\n\n"
            },
            {
                "role": "user",
                "content": "===== REQUIREMENTS =====\n1. The goal of the game is to complete 33 levels successfully.\n2. The board is 200 pixels wide horizontally and 300 pixels wide vertically.\n3. The bricks and the paddle are rectangular blocks with a width of 20 pixels and height of 10 pixels. The ball has a diameter of 10 pixels.\n4. At the beginning of each level, the ball starts from the top left corner of the board and moves downwards with a straight trajectory at a 45\u00b0 angle and a speed of 5 pixels per second.\n5. At each level, the user moves a paddle in order to hit a ball, making the ball change its direction upward.\n6. To successfully complete a level, the user needs to break all bricks on the board by hitting them with the ball.\n7. Each brick must be either blue, red, or gold and is sized single or double.\n8. A brick is sized single (20 x 10 pixels) or double (40 x 10 pixels).\n9. Blue bricks are destroyed with one hit, red bricks require two hits, gold bricks require three hits.\n10. The first level gets initialised with 50 blue, single bricks randomly placed on the upper third of the board.\n11. The paddle only moves horizontally on the bottom of the board, controlled by the user by left and right arrow keys. The paddle always stays inside the board. When each level starts the paddle resets to the center of the bottom border.\n12. The ball direction changes every time the ball hits the paddle or the border of the board (except for the bottom border) or a brick, with the same angle of reflection as the angle of incidence.\n13. Every time the next level starts, the speed of the ball increases by 1 pixel per second.\n14. When the user finishes a level, the next level with a different brick arrangement and increased difficulty begins. Each level adds two red bricks and one gold brick.\n15. The program shall generate the sizes of the new level's bricks (single or double) and the brick arrangement (where in the upper third of the board the bricks will spawn) randomly.\n16. The user has 3 lives.\n17. The user loses a life every time the ball falls off the bottom of the board.\n18. When the user loses a life but still has lives remaining, the level restarts. Once the user loses all lives, the game is over.\n19. When a game is over, the user shall decide if they want to play again. If they want to play again, the new game starts from level 1. Otherwise, the game ends."
            }
        ],
        "requirements": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19
        ],
        "requirements_smelly": [],
        "timestamp": "2025-03-31_103806"
    },
    {
        "name": "no_smells_01",
        "description": "Tracing with a random number of smells.",
        "group": "snake",
        "game": "snake",
        "code_language": "java",
        "iterations": 3,
        "llm": {
            "type": "GPT",
            "model": "gpt-4o",
            "temperature": 0
        },
        "prompts": [
            {
                "role": "system",
                "content": "You are a helpful assistant that generates a sequence diagram from the given requirements so that I can provide it to Planttext to\nvisualize it.\n\nInput: A list of game requirements. Each requirement will be labeled (e.g., 1., 2., etc.). Your task is to generate a PlantUML sequence diagram that:\n1. Represents the requirements in sequence diagram format.\n2. Includes sticky notes indicating which part of the diagram corresponds to each requirement. Each sticky note must follow this format: `note right of [Actor/Participant]: Rule [Number]`.\n3. You can use alt/end or alt/else/end blocks for conditional branching to visually represent alternative flows. Alt blocks can be nested.\n4. Some requirements may contain extra details (such as UI information, numerical data, component sizes or shapes) that are not directly related to system behavior or game mechanics. Append\nthese extra details as additional notes at the end of the diagram (just before the `@enduml` tag). Use newline with a new note component if there are too much information so that the diagram\ndoes not get too wide. Use the following syntax:\nnote right of <leftmost_participant/actor>: Rule <RuleID>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\n\nOutput: Only the JSON that containes the PlantUML sequence diagram. Do not add any explanations or comments.\n\nExample Input:\n1. The game is played by 2 players.\n2. In each turn, a player rolls a die. Then the other player rolls a die.\n3. The player who rolls a 6 gets 1 point.\n4. The player who rolls a 3 gets 2 points.\n5. If 2 players run the same die value, they both get 1 points. This rule overrules the rules about rolling 3 or 6.\n6. The player who reaches 10 points first, wins the game.\n7. A die is a classic white die which has values from 1 to 6.\n8. The game board has size 50 cm x 50 cm and it has borders that prevent dice to go out. The players roll the die into this board. If a die goes out, the roll is repeated. \n\nExample Output: Return a JSON object with the following structure:\n{\n  \"output\": \"@startuml\n<PlantUML diagram description that defines game mechanics comes here>\nnote right of Player: Rule 7\nnote right of Player: A die is a classic white die with values from 1 to 6\nnote right of Player: Rule 8\nnote right of Player: The game board has size 50 cm x 50 cm.\nnote right of Player: The players roll the dice into the game board.\nnote right of Player: Its borders prevent dice to go out.\n@enduml\"\n}\n\n"
            },
            {
                "role": "user",
                "content": "===== REQUIREMENTS =====\n1. The goal of the game is to grow the length of the snake by making the snake eat food until it fills the entire board.\n2. The snake eats food when it touches the food (namely every time the snake passes over food on the board).\n3. Every time the snake eats a piece of food, its body grows by one block which gets attached to the end of the body.\n4. If the snake touches a board side the game is over.\n5. If the snake touches its own body the game is over.\n6. The game board consists of k x k blocks, where k shall be given as input by the user. Every block, including the food and body blocks of the snake, shall have a size of 5 x 5 pixels.\n7. When the game starts, the board is initialised with a snake and a piece of food. The snake is represented as a single green block, positioned at the leftmost and bottommost block of the board. The initial direction shall be up. The piece of food is represented as a single red block placed at a random position on the board.\n8. When the user presses up, down, right, or left on the keyboard, the snake continues to move to the corresponding direction.\n9. Every time the snake eats a piece of food, a new piece of food shall be placed at a random position on the board.\n10. Every time the snake eats a piece of food, its speed increases by 1%.\n11. The user can set the difficulty to easy or hard. If the user selects \u201ceasy\u201d, the snake initially moves with a speed of 0.5 blocks per second. If the user selects \u201chard\u201d, the snake initially moves with a speed of 2 blocks per second.\n12. After the snake has eaten 10 pieces of food, a blue bonus piece of food should appear instead of the normal piece of food, at a random position on the board. When the snake eats that piece, three blocks shall be attached to the snake's body.\n13. Every 5 minutes, a golden bonus block shall appear additionally to the food block, at a random position on the board. If the snake eats the bonus block, the speed shall decrease by 5%.\n14. If the user presses p on the keyboard, the game shall pause until the user presses p again."
            }
        ],
        "requirements": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14
        ],
        "requirements_smelly": [],
        "timestamp": "2025-03-31_103806"
    },
    {
        "name": "all_smells_01",
        "description": "Tracing with a random number of smells.",
        "group": "arkanoid",
        "game": "arkanoid",
        "code_language": "java",
        "iterations": 3,
        "llm": {
            "type": "GPT",
            "model": "gpt-4o",
            "temperature": 0
        },
        "prompts": [
            {
                "role": "system",
                "content": "You are a helpful assistant that generates a sequence diagram from the given requirements so that I can provide it to Planttext to\nvisualize it.\n\nInput: A list of game requirements. Each requirement will be labeled (e.g., 1., 2., etc.). Your task is to generate a PlantUML sequence diagram that:\n1. Represents the requirements in sequence diagram format.\n2. Includes sticky notes indicating which part of the diagram corresponds to each requirement. Each sticky note must follow this format: `note right of [Actor/Participant]: Rule [Number]`.\n3. You can use alt/end or alt/else/end blocks for conditional branching to visually represent alternative flows. Alt blocks can be nested.\n4. Some requirements may contain extra details (such as UI information, numerical data, component sizes or shapes) that are not directly related to system behavior or game mechanics. Append\nthese extra details as additional notes at the end of the diagram (just before the `@enduml` tag). Use newline with a new note component if there are too much information so that the diagram\ndoes not get too wide. Use the following syntax:\nnote right of <leftmost_participant/actor>: Rule <RuleID>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\n\nOutput: Only the JSON that containes the PlantUML sequence diagram. Do not add any explanations or comments.\n\nExample Input:\n1. The game is played by 2 players.\n2. In each turn, a player rolls a die. Then the other player rolls a die.\n3. The player who rolls a 6 gets 1 point.\n4. The player who rolls a 3 gets 2 points.\n5. If 2 players run the same die value, they both get 1 points. This rule overrules the rules about rolling 3 or 6.\n6. The player who reaches 10 points first, wins the game.\n7. A die is a classic white die which has values from 1 to 6.\n8. The game board has size 50 cm x 50 cm and it has borders that prevent dice to go out. The players roll the die into this board. If a die goes out, the roll is repeated. \n\nExample Output: Return a JSON object with the following structure:\n{\n  \"output\": \"@startuml\n<PlantUML diagram description that defines game mechanics comes here>\nnote right of Player: Rule 7\nnote right of Player: A die is a classic white die with values from 1 to 6\nnote right of Player: Rule 8\nnote right of Player: The game board has size 50 cm x 50 cm.\nnote right of Player: The players roll the dice into the game board.\nnote right of Player: Its borders prevent dice to go out.\n@enduml\"\n}\n\n"
            },
            {
                "role": "user",
                "content": "===== REQUIREMENTS =====\n1. The goal of the game is to complete 33 levels successfully.\n2. The board is 200 pixels wide horizontally and 300 pixels wide vertically.\n3. The bricks and the paddle are rectangular blocks with a width of 20 pixels and height of 10 pixels. The ball has a diameter of 10 pixels.\n4. At the beginning of each level, the ball starts from the top left corner of the board and moves downwards with a straight trajectory at a 45\u00b0 angle and a speed of 5 pixels per second.\n5. At each level, the user moves a paddle in order to hit a ball, making it change its direction upward.\n6. To successfully complete a level, the user needs to break all bricks.\n7. Bricks can have a color (blue, red, gold) and can be sized single or double.\n8. A brick is sized single (20 x 10 pixels) or double (60 x 10 pixels).\n9. Blue bricks are destroyed with one hit, red bricks require two hits, yellow bricks require three hits.\n10. The first level gets initialised with 50 blue, single bricks that are placed in the brick section of the board.\n11. The paddle only moves horizontally on the bottom of the board, controlled by the user by left and right arrow keys. The paddle cannot go outside the board. When each level starts the paddle resets to the center of the bottom border.\n12. The ball direction changes every time the ball hits the paddle or the border of the board (except for the bottom border) or a brick, with the correct angle of reflection.\n13. Every time the next level starts, the speed of the ball increases by a sufficient amount.\n14. When the user finishes a level, the next level with a different brick arrangement and increased difficulty begins. Each level removes two red bricks and one gold brick.\n15. The sizes of the new level's bricks (single or double) and the brick arrangement (where in the upper third of the board the bricks will spawn) are randomly generated.\n16. 3 lives are given to a user.\n17. The user loses a life every time the ball falls of the side of the board.\n18. When the user loses a life but still has lives remaining, the level should restart if possible. Once the user loses all lives, the game is over.\n19. When a game is over, it can be started again from level 1 or ended."
            }
        ],
        "requirements": [
            1,
            2,
            3,
            4
        ],
        "requirements_smelly": [
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19
        ],
        "timestamp": "2025-03-31_103806"
    },
    {
        "name": "all_smells_01",
        "description": "Tracing with a random number of smells.",
        "group": "snake",
        "game": "snake",
        "code_language": "java",
        "iterations": 3,
        "llm": {
            "type": "GPT",
            "model": "gpt-4o",
            "temperature": 0
        },
        "prompts": [
            {
                "role": "system",
                "content": "You are a helpful assistant that generates a sequence diagram from the given requirements so that I can provide it to Planttext to\nvisualize it.\n\nInput: A list of game requirements. Each requirement will be labeled (e.g., 1., 2., etc.). Your task is to generate a PlantUML sequence diagram that:\n1. Represents the requirements in sequence diagram format.\n2. Includes sticky notes indicating which part of the diagram corresponds to each requirement. Each sticky note must follow this format: `note right of [Actor/Participant]: Rule [Number]`.\n3. You can use alt/end or alt/else/end blocks for conditional branching to visually represent alternative flows. Alt blocks can be nested.\n4. Some requirements may contain extra details (such as UI information, numerical data, component sizes or shapes) that are not directly related to system behavior or game mechanics. Append\nthese extra details as additional notes at the end of the diagram (just before the `@enduml` tag). Use newline with a new note component if there are too much information so that the diagram\ndoes not get too wide. Use the following syntax:\nnote right of <leftmost_participant/actor>: Rule <RuleID>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\n\nOutput: Only the JSON that containes the PlantUML sequence diagram. Do not add any explanations or comments.\n\nExample Input:\n1. The game is played by 2 players.\n2. In each turn, a player rolls a die. Then the other player rolls a die.\n3. The player who rolls a 6 gets 1 point.\n4. The player who rolls a 3 gets 2 points.\n5. If 2 players run the same die value, they both get 1 points. This rule overrules the rules about rolling 3 or 6.\n6. The player who reaches 10 points first, wins the game.\n7. A die is a classic white die which has values from 1 to 6.\n8. The game board has size 50 cm x 50 cm and it has borders that prevent dice to go out. The players roll the die into this board. If a die goes out, the roll is repeated. \n\nExample Output: Return a JSON object with the following structure:\n{\n  \"output\": \"@startuml\n<PlantUML diagram description that defines game mechanics comes here>\nnote right of Player: Rule 7\nnote right of Player: A die is a classic white die with values from 1 to 6\nnote right of Player: Rule 8\nnote right of Player: The game board has size 50 cm x 50 cm.\nnote right of Player: The players roll the dice into the game board.\nnote right of Player: Its borders prevent dice to go out.\n@enduml\"\n}\n\n"
            },
            {
                "role": "user",
                "content": "===== REQUIREMENTS =====\n1. The goal of the game is to grow the length of the snake by making the snake eat food until it fills the entire board.\n2. The snake eats food when it touches the food (namely every time the snake passes over food on the board).\n3. Every time the snake eats a piece of food, its body grows by one block which gets attached to the end of the body.\n4. The snake must not touch a board side.\n5. The game is over as soon as the snake's body is touched.\n6. The game board consists of k x k blocks, where k shall be given as input by the user. Every block, including the food and body blocks of the snake, shall have a size such that there are enough blocks to play the game correctly.\n7. When the game starts, the board is initialised with a snake and a piece of food. It shall be represented as a single green block, positioned at the leftmost and bottommost block of the board. The initial direction shall be up. The other is represented as a single red block placed at a random position on the board.\n8. The snake could be moved by pressing up, down, right, or left on the keyboard.\n9. Every time the snake eats a piece of food,  a new one shall appear.\n10. Every time the snake eats a piece of food, its speed increases by 10 milliseconds.\n11. The user can set the difficulty to easy or hard. If the user selects \u201ceasy\u201d, the snake initially moves with a speed of 0.5 blocks per second.\n12. After the snake has eaten many pieces of food, a blue bonus piece of food should appear instead of the normal piece of food, at a random position on the board. When the snake eats that piece, three blocks shall be attached to the snake's body.\n13. Sometimes, a golden bonus block shall appear additionally to the food block, at a random position on the board. If the snake eats the bonus block, the speed shall decrease by 5%.\n14. If the user presses p on the keyboard, the game shall pause until the user presses q again."
            }
        ],
        "requirements": [
            1,
            2,
            3
        ],
        "requirements_smelly": [
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14
        ],
        "timestamp": "2025-03-31_103806"
    },
    {
        "name": "random_01",
        "description": "Tracing with a random number of smells.",
        "group": "arkanoid",
        "game": "arkanoid",
        "code_language": "java",
        "iterations": 3,
        "llm": {
            "type": "GPT",
            "model": "gpt-4o",
            "temperature": 0
        },
        "prompts": [
            {
                "role": "system",
                "content": "You are a helpful assistant that generates a sequence diagram from the given requirements so that I can provide it to Planttext to\nvisualize it.\n\nInput: A list of game requirements. Each requirement will be labeled (e.g., 1., 2., etc.). Your task is to generate a PlantUML sequence diagram that:\n1. Represents the requirements in sequence diagram format.\n2. Includes sticky notes indicating which part of the diagram corresponds to each requirement. Each sticky note must follow this format: `note right of [Actor/Participant]: Rule [Number]`.\n3. You can use alt/end or alt/else/end blocks for conditional branching to visually represent alternative flows. Alt blocks can be nested.\n4. Some requirements may contain extra details (such as UI information, numerical data, component sizes or shapes) that are not directly related to system behavior or game mechanics. Append\nthese extra details as additional notes at the end of the diagram (just before the `@enduml` tag). Use newline with a new note component if there are too much information so that the diagram\ndoes not get too wide. Use the following syntax:\nnote right of <leftmost_participant/actor>: Rule <RuleID>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\n\nOutput: Only the JSON that containes the PlantUML sequence diagram. Do not add any explanations or comments.\n\nExample Input:\n1. The game is played by 2 players.\n2. In each turn, a player rolls a die. Then the other player rolls a die.\n3. The player who rolls a 6 gets 1 point.\n4. The player who rolls a 3 gets 2 points.\n5. If 2 players run the same die value, they both get 1 points. This rule overrules the rules about rolling 3 or 6.\n6. The player who reaches 10 points first, wins the game.\n7. A die is a classic white die which has values from 1 to 6.\n8. The game board has size 50 cm x 50 cm and it has borders that prevent dice to go out. The players roll the die into this board. If a die goes out, the roll is repeated. \n\nExample Output: Return a JSON object with the following structure:\n{\n  \"output\": \"@startuml\n<PlantUML diagram description that defines game mechanics comes here>\nnote right of Player: Rule 7\nnote right of Player: A die is a classic white die with values from 1 to 6\nnote right of Player: Rule 8\nnote right of Player: The game board has size 50 cm x 50 cm.\nnote right of Player: The players roll the dice into the game board.\nnote right of Player: Its borders prevent dice to go out.\n@enduml\"\n}\n\n"
            },
            {
                "role": "user",
                "content": "===== REQUIREMENTS =====\n1. The goal of the game is to complete 33 levels successfully.\n2. The board is 200 pixels wide horizontally and 300 pixels wide vertically.\n3. The bricks and the paddle are rectangular blocks with a width of 20 pixels and height of 10 pixels. The ball has a diameter of 10 pixels.\n4. At the beginning of each level, the ball starts from the top left corner of the board and moves downwards with a straight trajectory at a 45\u00b0 angle and a speed of 5 pixels per second.\n5. At each level, the user moves a paddle in order to hit a ball, making the ball change its direction upward.\n6. To successfully complete a level, the user needs to break all bricks.\n7. Bricks can have a color (blue, red, gold) and can be sized single or double.\n8. A brick is sized single (20 x 10 pixels) or double (60 x 10 pixels).\n9. Blue bricks are destroyed with one hit, red bricks require two hits, gold bricks require three hits.\n10. The first level gets initialised with 50 blue, single bricks that are placed in the brick section of the board.\n11. The paddle only moves horizontally on the bottom of the board, controlled by the user by left and right arrow keys. The paddle cannot go outside the board. When each level starts the paddle resets to the center of the bottom border.\n12. The ball direction changes every time the ball hits the paddle or the border of the board (except for the bottom border) or a brick, with the correct angle of reflection.\n13. Every time the next level starts, the speed of the ball increases by a sufficient amount.\n14. When the user finishes a level, the next level with a different brick arrangement and increased difficulty begins. Each level removes two red bricks and one gold brick.\n15. The sizes of the new level's bricks (single or double) and the brick arrangement (where in the upper third of the board the bricks will spawn) are randomly generated.\n16. 3 lives are given to a user.\n17. The user loses a life every time the ball falls of the side of the board.\n18. When the user loses a life but still has lives remaining, the level should restart if possible. Once the user loses all lives, the game is over.\n19. When a game is over, it can be started again from level 1 or ended."
            }
        ],
        "requirements": [
            1,
            2,
            3,
            4,
            5,
            9
        ],
        "requirements_smelly": [
            6,
            7,
            8,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19
        ],
        "timestamp": "2025-03-31_103806"
    },
    {
        "name": "random_02",
        "description": "Tracing with a random number of smells.",
        "group": "arkanoid",
        "game": "arkanoid",
        "code_language": "java",
        "iterations": 3,
        "llm": {
            "type": "GPT",
            "model": "gpt-4o",
            "temperature": 0
        },
        "prompts": [
            {
                "role": "system",
                "content": "You are a helpful assistant that generates a sequence diagram from the given requirements so that I can provide it to Planttext to\nvisualize it.\n\nInput: A list of game requirements. Each requirement will be labeled (e.g., 1., 2., etc.). Your task is to generate a PlantUML sequence diagram that:\n1. Represents the requirements in sequence diagram format.\n2. Includes sticky notes indicating which part of the diagram corresponds to each requirement. Each sticky note must follow this format: `note right of [Actor/Participant]: Rule [Number]`.\n3. You can use alt/end or alt/else/end blocks for conditional branching to visually represent alternative flows. Alt blocks can be nested.\n4. Some requirements may contain extra details (such as UI information, numerical data, component sizes or shapes) that are not directly related to system behavior or game mechanics. Append\nthese extra details as additional notes at the end of the diagram (just before the `@enduml` tag). Use newline with a new note component if there are too much information so that the diagram\ndoes not get too wide. Use the following syntax:\nnote right of <leftmost_participant/actor>: Rule <RuleID>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\n\nOutput: Only the JSON that containes the PlantUML sequence diagram. Do not add any explanations or comments.\n\nExample Input:\n1. The game is played by 2 players.\n2. In each turn, a player rolls a die. Then the other player rolls a die.\n3. The player who rolls a 6 gets 1 point.\n4. The player who rolls a 3 gets 2 points.\n5. If 2 players run the same die value, they both get 1 points. This rule overrules the rules about rolling 3 or 6.\n6. The player who reaches 10 points first, wins the game.\n7. A die is a classic white die which has values from 1 to 6.\n8. The game board has size 50 cm x 50 cm and it has borders that prevent dice to go out. The players roll the die into this board. If a die goes out, the roll is repeated. \n\nExample Output: Return a JSON object with the following structure:\n{\n  \"output\": \"@startuml\n<PlantUML diagram description that defines game mechanics comes here>\nnote right of Player: Rule 7\nnote right of Player: A die is a classic white die with values from 1 to 6\nnote right of Player: Rule 8\nnote right of Player: The game board has size 50 cm x 50 cm.\nnote right of Player: The players roll the dice into the game board.\nnote right of Player: Its borders prevent dice to go out.\n@enduml\"\n}\n\n"
            },
            {
                "role": "user",
                "content": "===== REQUIREMENTS =====\n1. The goal of the game is to complete 33 levels successfully.\n2. The board is 200 pixels wide horizontally and 300 pixels wide vertically.\n3. The bricks and the paddle are rectangular blocks with a width of 20 pixels and height of 10 pixels. The ball has a diameter of 10 pixels.\n4. At the beginning of each level, the ball starts from the top left corner of the board and moves downwards with a straight trajectory at a 45\u00b0 angle and a speed of 5 pixels per second.\n5. At each level, the user moves a paddle in order to hit a ball, making it change its direction upward.\n6. To successfully complete a level, the user needs to break all bricks.\n7. Bricks can have a color (blue, red, gold) and can be sized single or double.\n8. A brick is sized single (20 x 10 pixels) or double (60 x 10 pixels).\n9. Blue bricks are destroyed with one hit, red bricks require two hits, yellow bricks require three hits.\n10. The first level gets initialised with 50 blue, single bricks that are placed in the brick section of the board.\n11. The paddle only moves horizontally on the bottom of the board, controlled by the user by left and right arrow keys. The paddle cannot go outside the board. When each level starts the paddle resets to the center of the bottom border.\n12. The ball direction changes every time the ball hits the paddle or the border of the board (except for the bottom border) or a brick, with the correct angle of reflection.\n13. Every time the next level starts, the speed of the ball increases by a sufficient amount.\n14. When the user finishes a level, the next level with a different brick arrangement and increased difficulty begins. Each level removes two red bricks and one gold brick.\n15. The sizes of the new level's bricks (single or double) and the brick arrangement (where in the upper third of the board the bricks will spawn) are randomly generated.\n16. 3 lives are given to a user.\n17. The user loses a life every time the ball falls of the side of the board.\n18. When the user loses a life but still has lives remaining, the level restarts. Once the user loses all lives, the game is over.\n19. When a game is over, it can be started again from level 1 or ended."
            }
        ],
        "requirements": [
            1,
            2,
            3,
            4,
            18
        ],
        "requirements_smelly": [
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            19
        ],
        "timestamp": "2025-03-31_103806"
    },
    {
        "name": "random_01",
        "description": "Tracing with a random number of smells.",
        "group": "snake",
        "game": "snake",
        "code_language": "java",
        "iterations": 3,
        "llm": {
            "type": "GPT",
            "model": "gpt-4o",
            "temperature": 0
        },
        "prompts": [
            {
                "role": "system",
                "content": "You are a helpful assistant that generates a sequence diagram from the given requirements so that I can provide it to Planttext to\nvisualize it.\n\nInput: A list of game requirements. Each requirement will be labeled (e.g., 1., 2., etc.). Your task is to generate a PlantUML sequence diagram that:\n1. Represents the requirements in sequence diagram format.\n2. Includes sticky notes indicating which part of the diagram corresponds to each requirement. Each sticky note must follow this format: `note right of [Actor/Participant]: Rule [Number]`.\n3. You can use alt/end or alt/else/end blocks for conditional branching to visually represent alternative flows. Alt blocks can be nested.\n4. Some requirements may contain extra details (such as UI information, numerical data, component sizes or shapes) that are not directly related to system behavior or game mechanics. Append\nthese extra details as additional notes at the end of the diagram (just before the `@enduml` tag). Use newline with a new note component if there are too much information so that the diagram\ndoes not get too wide. Use the following syntax:\nnote right of <leftmost_participant/actor>: Rule <RuleID>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\n\nOutput: Only the JSON that containes the PlantUML sequence diagram. Do not add any explanations or comments.\n\nExample Input:\n1. The game is played by 2 players.\n2. In each turn, a player rolls a die. Then the other player rolls a die.\n3. The player who rolls a 6 gets 1 point.\n4. The player who rolls a 3 gets 2 points.\n5. If 2 players run the same die value, they both get 1 points. This rule overrules the rules about rolling 3 or 6.\n6. The player who reaches 10 points first, wins the game.\n7. A die is a classic white die which has values from 1 to 6.\n8. The game board has size 50 cm x 50 cm and it has borders that prevent dice to go out. The players roll the die into this board. If a die goes out, the roll is repeated. \n\nExample Output: Return a JSON object with the following structure:\n{\n  \"output\": \"@startuml\n<PlantUML diagram description that defines game mechanics comes here>\nnote right of Player: Rule 7\nnote right of Player: A die is a classic white die with values from 1 to 6\nnote right of Player: Rule 8\nnote right of Player: The game board has size 50 cm x 50 cm.\nnote right of Player: The players roll the dice into the game board.\nnote right of Player: Its borders prevent dice to go out.\n@enduml\"\n}\n\n"
            },
            {
                "role": "user",
                "content": "===== REQUIREMENTS =====\n1. The goal of the game is to grow the length of the snake by making the snake eat food until it fills the entire board.\n2. The snake eats food when it touches the food (namely every time the snake passes over food on the board).\n3. Every time the snake eats a piece of food, its body grows by one block which gets attached to the end of the body.\n4. The snake must not touch a board side.\n5. If the snake touches its own body the game is over.\n6. The game board consists of k x k blocks, where k shall be given as input by the user. Every block, including the food and body blocks of the snake, shall have a size of 5 x 5 pixels.\n7. When the game starts, the board is initialised with a snake and a piece of food. The snake is represented as a single green block, positioned at the leftmost and bottommost block of the board. The initial direction shall be up. The piece of food is represented as a single red block placed at a random position on the board.\n8. The snake could be moved by pressing up, down, right, or left on the keyboard.\n9. Every time the snake eats a piece of food, a new piece of food shall be placed at a random position on the board.\n10. Every time the snake eats a piece of food, its speed increases by 10 milliseconds.\n11. The user can set the difficulty to easy or hard. If the user selects \u201ceasy\u201d, the snake initially moves with a speed of 0.5 blocks per second.\n12. After the snake has eaten 10 pieces of food, a blue bonus piece of food should appear instead of the normal piece of food, at a random position on the board. When the snake eats that piece, three blocks shall be attached to the snake's body.\n13. Sometimes, a golden bonus block shall appear additionally to the food block, at a random position on the board. If the snake eats the bonus block, the speed shall decrease by 5%.\n14. If the user presses p on the keyboard, the game shall pause until the user presses p again."
            }
        ],
        "requirements": [
            1,
            2,
            3,
            5,
            6,
            7,
            9,
            12,
            14
        ],
        "requirements_smelly": [
            4,
            8,
            10,
            11,
            13
        ],
        "timestamp": "2025-03-31_103806"
    },
    {
        "name": "random_02",
        "description": "Tracing with a random number of smells.",
        "group": "snake",
        "game": "snake",
        "code_language": "java",
        "iterations": 3,
        "llm": {
            "type": "GPT",
            "model": "gpt-4o",
            "temperature": 0
        },
        "prompts": [
            {
                "role": "system",
                "content": "You are a helpful assistant that generates a sequence diagram from the given requirements so that I can provide it to Planttext to\nvisualize it.\n\nInput: A list of game requirements. Each requirement will be labeled (e.g., 1., 2., etc.). Your task is to generate a PlantUML sequence diagram that:\n1. Represents the requirements in sequence diagram format.\n2. Includes sticky notes indicating which part of the diagram corresponds to each requirement. Each sticky note must follow this format: `note right of [Actor/Participant]: Rule [Number]`.\n3. You can use alt/end or alt/else/end blocks for conditional branching to visually represent alternative flows. Alt blocks can be nested.\n4. Some requirements may contain extra details (such as UI information, numerical data, component sizes or shapes) that are not directly related to system behavior or game mechanics. Append\nthese extra details as additional notes at the end of the diagram (just before the `@enduml` tag). Use newline with a new note component if there are too much information so that the diagram\ndoes not get too wide. Use the following syntax:\nnote right of <leftmost_participant/actor>: Rule <RuleID>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\n\nOutput: Only the JSON that containes the PlantUML sequence diagram. Do not add any explanations or comments.\n\nExample Input:\n1. The game is played by 2 players.\n2. In each turn, a player rolls a die. Then the other player rolls a die.\n3. The player who rolls a 6 gets 1 point.\n4. The player who rolls a 3 gets 2 points.\n5. If 2 players run the same die value, they both get 1 points. This rule overrules the rules about rolling 3 or 6.\n6. The player who reaches 10 points first, wins the game.\n7. A die is a classic white die which has values from 1 to 6.\n8. The game board has size 50 cm x 50 cm and it has borders that prevent dice to go out. The players roll the die into this board. If a die goes out, the roll is repeated. \n\nExample Output: Return a JSON object with the following structure:\n{\n  \"output\": \"@startuml\n<PlantUML diagram description that defines game mechanics comes here>\nnote right of Player: Rule 7\nnote right of Player: A die is a classic white die with values from 1 to 6\nnote right of Player: Rule 8\nnote right of Player: The game board has size 50 cm x 50 cm.\nnote right of Player: The players roll the dice into the game board.\nnote right of Player: Its borders prevent dice to go out.\n@enduml\"\n}\n\n"
            },
            {
                "role": "user",
                "content": "===== REQUIREMENTS =====\n1. The goal of the game is to grow the length of the snake by making the snake eat food until it fills the entire board.\n2. The snake eats food when it touches the food (namely every time the snake passes over food on the board).\n3. Every time the snake eats a piece of food, its body grows by one block which gets attached to the end of the body.\n4. The snake must not touch a board side.\n5. If the snake touches its own body the game is over.\n6. The game board consists of k x k blocks, where k shall be given as input by the user. Every block, including the food and body blocks of the snake, shall have a size such that there are enough blocks to play the game correctly.\n7. When the game starts, the board is initialised with a snake and a piece of food. The snake is represented as a single green block, positioned at the leftmost and bottommost block of the board. The initial direction shall be up. The piece of food is represented as a single red block placed at a random position on the board.\n8. The snake could be moved by pressing up, down, right, or left on the keyboard.\n9. Every time the snake eats a piece of food, a new piece of food shall be placed at a random position on the board.\n10. Every time the snake eats a piece of food, its speed increases by 1%.\n11. The user can set the difficulty to easy or hard. If the user selects \u201ceasy\u201d, the snake initially moves with a speed of 0.5 blocks per second. If the user selects \u201chard\u201d, the snake initially moves with a speed of 2 blocks per second.\n12. After the snake has eaten 10 pieces of food, a blue bonus piece of food should appear instead of the normal piece of food, at a random position on the board. When the snake eats that piece, three blocks shall be attached to the snake's body.\n13. Sometimes, a golden bonus block shall appear additionally to the food block, at a random position on the board. If the snake eats the bonus block, the speed shall decrease by 5%.\n14. If the user presses p on the keyboard, the game shall pause until the user presses p again."
            }
        ],
        "requirements": [
            1,
            2,
            3,
            5,
            7,
            9,
            10,
            11,
            12,
            14
        ],
        "requirements_smelly": [
            4,
            6,
            8,
            13
        ],
        "timestamp": "2025-03-31_103806"
    },
    {
        "name": "only_lexical_smells_01",
        "description": "Tracing with a random number of smells.",
        "group": "arkanoid",
        "game": "arkanoid",
        "code_language": "java",
        "iterations": 3,
        "llm": {
            "type": "GPT",
            "model": "gpt-4o",
            "temperature": 0
        },
        "prompts": [
            {
                "role": "system",
                "content": "You are a helpful assistant that generates a sequence diagram from the given requirements so that I can provide it to Planttext to\nvisualize it.\n\nInput: A list of game requirements. Each requirement will be labeled (e.g., 1., 2., etc.). Your task is to generate a PlantUML sequence diagram that:\n1. Represents the requirements in sequence diagram format.\n2. Includes sticky notes indicating which part of the diagram corresponds to each requirement. Each sticky note must follow this format: `note right of [Actor/Participant]: Rule [Number]`.\n3. You can use alt/end or alt/else/end blocks for conditional branching to visually represent alternative flows. Alt blocks can be nested.\n4. Some requirements may contain extra details (such as UI information, numerical data, component sizes or shapes) that are not directly related to system behavior or game mechanics. Append\nthese extra details as additional notes at the end of the diagram (just before the `@enduml` tag). Use newline with a new note component if there are too much information so that the diagram\ndoes not get too wide. Use the following syntax:\nnote right of <leftmost_participant/actor>: Rule <RuleID>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\n\nOutput: Only the JSON that containes the PlantUML sequence diagram. Do not add any explanations or comments.\n\nExample Input:\n1. The game is played by 2 players.\n2. In each turn, a player rolls a die. Then the other player rolls a die.\n3. The player who rolls a 6 gets 1 point.\n4. The player who rolls a 3 gets 2 points.\n5. If 2 players run the same die value, they both get 1 points. This rule overrules the rules about rolling 3 or 6.\n6. The player who reaches 10 points first, wins the game.\n7. A die is a classic white die which has values from 1 to 6.\n8. The game board has size 50 cm x 50 cm and it has borders that prevent dice to go out. The players roll the die into this board. If a die goes out, the roll is repeated. \n\nExample Output: Return a JSON object with the following structure:\n{\n  \"output\": \"@startuml\n<PlantUML diagram description that defines game mechanics comes here>\nnote right of Player: Rule 7\nnote right of Player: A die is a classic white die with values from 1 to 6\nnote right of Player: Rule 8\nnote right of Player: The game board has size 50 cm x 50 cm.\nnote right of Player: The players roll the dice into the game board.\nnote right of Player: Its borders prevent dice to go out.\n@enduml\"\n}\n\n"
            },
            {
                "role": "user",
                "content": "===== REQUIREMENTS =====\n1. The goal of the game is to complete 33 levels successfully.\n2. The board is 200 pixels wide horizontally and 300 pixels wide vertically.\n3. The bricks and the paddle are rectangular blocks with a width of 20 pixels and height of 10 pixels. The ball has a diameter of 10 pixels.\n4. At the beginning of each level, the ball starts from the top left corner of the board and moves downwards with a straight trajectory at a 45\u00b0 angle and a speed of 5 pixels per second.\n5. At each level, the user moves a paddle in order to hit a ball, making the ball change its direction upward.\n6. To successfully complete a level, the user needs to break all bricks on the board by hitting them with the ball.\n7. Bricks can have a color (blue, red, gold) and can be sized single or double.\n8. A brick is sized single (20 x 10 pixels) or double (40 x 10 pixels).\n9. Blue bricks are destroyed with one hit, red bricks require two hits, gold bricks require three hits.\n10. The first level gets initialised with 50 blue, single bricks randomly placed on the upper third of the board.\n11. The paddle only moves horizontally on the bottom of the board, controlled by the user by left and right arrow keys. The paddle always stays inside the board. When each level starts the paddle resets to the center of the bottom border.\n12. The ball direction changes every time the ball hits the paddle or the border of the board (except for the bottom border) or a brick, with the correct angle of reflection.\n13. Every time the next level starts, the speed of the ball increases by a sufficient amount.\n14. When the user finishes a level, the next level with a different brick arrangement and increased difficulty begins. Each level adds two red bricks and one gold brick.\n15. The program shall generate the sizes of the new level's bricks (single or double) and the brick arrangement (where in the upper third of the board the bricks will spawn) randomly.\n16. The user has 3 lives.\n17. The user loses a life every time the ball falls off the bottom of the board.\n18. When the user loses a life but still has lives remaining, the level should restart if possible. Once the user loses all lives, the game is over.\n19. When a game is over, the user shall decide if they want to play again. If they want to play again, the new game starts from level 1. Otherwise, the game ends."
            }
        ],
        "requirements": [
            1,
            2,
            3,
            4,
            5,
            6,
            8,
            9,
            10,
            11,
            14,
            15,
            16,
            17,
            19
        ],
        "requirements_smelly": [
            7,
            12,
            13,
            18
        ],
        "timestamp": "2025-03-31_103806"
    },
    {
        "name": "only_semantic_smells_01",
        "description": "Tracing with a random number of smells.",
        "group": "arkanoid",
        "game": "arkanoid",
        "code_language": "java",
        "iterations": 3,
        "llm": {
            "type": "GPT",
            "model": "gpt-4o",
            "temperature": 0
        },
        "prompts": [
            {
                "role": "system",
                "content": "You are a helpful assistant that generates a sequence diagram from the given requirements so that I can provide it to Planttext to\nvisualize it.\n\nInput: A list of game requirements. Each requirement will be labeled (e.g., 1., 2., etc.). Your task is to generate a PlantUML sequence diagram that:\n1. Represents the requirements in sequence diagram format.\n2. Includes sticky notes indicating which part of the diagram corresponds to each requirement. Each sticky note must follow this format: `note right of [Actor/Participant]: Rule [Number]`.\n3. You can use alt/end or alt/else/end blocks for conditional branching to visually represent alternative flows. Alt blocks can be nested.\n4. Some requirements may contain extra details (such as UI information, numerical data, component sizes or shapes) that are not directly related to system behavior or game mechanics. Append\nthese extra details as additional notes at the end of the diagram (just before the `@enduml` tag). Use newline with a new note component if there are too much information so that the diagram\ndoes not get too wide. Use the following syntax:\nnote right of <leftmost_participant/actor>: Rule <RuleID>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\n\nOutput: Only the JSON that containes the PlantUML sequence diagram. Do not add any explanations or comments.\n\nExample Input:\n1. The game is played by 2 players.\n2. In each turn, a player rolls a die. Then the other player rolls a die.\n3. The player who rolls a 6 gets 1 point.\n4. The player who rolls a 3 gets 2 points.\n5. If 2 players run the same die value, they both get 1 points. This rule overrules the rules about rolling 3 or 6.\n6. The player who reaches 10 points first, wins the game.\n7. A die is a classic white die which has values from 1 to 6.\n8. The game board has size 50 cm x 50 cm and it has borders that prevent dice to go out. The players roll the die into this board. If a die goes out, the roll is repeated. \n\nExample Output: Return a JSON object with the following structure:\n{\n  \"output\": \"@startuml\n<PlantUML diagram description that defines game mechanics comes here>\nnote right of Player: Rule 7\nnote right of Player: A die is a classic white die with values from 1 to 6\nnote right of Player: Rule 8\nnote right of Player: The game board has size 50 cm x 50 cm.\nnote right of Player: The players roll the dice into the game board.\nnote right of Player: Its borders prevent dice to go out.\n@enduml\"\n}\n\n"
            },
            {
                "role": "user",
                "content": "===== REQUIREMENTS =====\n1. The goal of the game is to complete 33 levels successfully.\n2. The board is 200 pixels wide horizontally and 300 pixels wide vertically.\n3. The bricks and the paddle are rectangular blocks with a width of 20 pixels and height of 10 pixels. The ball has a diameter of 10 pixels.\n4. At the beginning of each level, the ball starts from the top left corner of the board and moves downwards with a straight trajectory at a 45\u00b0 angle and a speed of 5 pixels per second.\n5. At each level, the user moves a paddle in order to hit a ball, making the ball change its direction upward.\n6. To successfully complete a level, the user needs to break all bricks.\n7. Each brick must be either blue, red, or gold and is sized single or double.\n8. A brick is sized single (20 x 10 pixels) or double (60 x 10 pixels).\n9. Blue bricks are destroyed with one hit, red bricks require two hits, yellow bricks require three hits.\n10. The first level gets initialised with 50 blue, single bricks that are placed in the brick section of the board.\n11. The paddle only moves horizontally on the bottom of the board, controlled by the user by left and right arrow keys. The paddle always stays inside the board. When each level starts the paddle resets to the center of the bottom border.\n12. The ball direction changes every time the ball hits the paddle or the border of the board (except for the bottom border) or a brick, with the same angle of reflection as the angle of incidence.\n13. Every time the next level starts, the speed of the ball increases by 1 pixel per second.\n14. When the user finishes a level, the next level with a different brick arrangement and increased difficulty begins. Each level removes two red bricks and one gold brick.\n15. The program shall generate the sizes of the new level's bricks (single or double) and the brick arrangement (where in the upper third of the board the bricks will spawn) randomly.\n16. The user has 3 lives.\n17. The user loses a life every time the ball falls of the side of the board.\n18. When the user loses a life but still has lives remaining, the level restarts. Once the user loses all lives, the game is over.\n19. When a game is over, it can be started again from level 1 or ended."
            }
        ],
        "requirements": [
            1,
            2,
            3,
            4,
            5,
            7,
            11,
            12,
            13,
            15,
            16,
            18
        ],
        "requirements_smelly": [
            6,
            8,
            9,
            10,
            14,
            17,
            19
        ],
        "timestamp": "2025-03-31_103806"
    },
    {
        "name": "only_syntactic_smells_01",
        "description": "Tracing with a random number of smells.",
        "group": "arkanoid",
        "game": "arkanoid",
        "code_language": "java",
        "iterations": 3,
        "llm": {
            "type": "GPT",
            "model": "gpt-4o",
            "temperature": 0
        },
        "prompts": [
            {
                "role": "system",
                "content": "You are a helpful assistant that generates a sequence diagram from the given requirements so that I can provide it to Planttext to\nvisualize it.\n\nInput: A list of game requirements. Each requirement will be labeled (e.g., 1., 2., etc.). Your task is to generate a PlantUML sequence diagram that:\n1. Represents the requirements in sequence diagram format.\n2. Includes sticky notes indicating which part of the diagram corresponds to each requirement. Each sticky note must follow this format: `note right of [Actor/Participant]: Rule [Number]`.\n3. You can use alt/end or alt/else/end blocks for conditional branching to visually represent alternative flows. Alt blocks can be nested.\n4. Some requirements may contain extra details (such as UI information, numerical data, component sizes or shapes) that are not directly related to system behavior or game mechanics. Append\nthese extra details as additional notes at the end of the diagram (just before the `@enduml` tag). Use newline with a new note component if there are too much information so that the diagram\ndoes not get too wide. Use the following syntax:\nnote right of <leftmost_participant/actor>: Rule <RuleID>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\n\nOutput: Only the JSON that containes the PlantUML sequence diagram. Do not add any explanations or comments.\n\nExample Input:\n1. The game is played by 2 players.\n2. In each turn, a player rolls a die. Then the other player rolls a die.\n3. The player who rolls a 6 gets 1 point.\n4. The player who rolls a 3 gets 2 points.\n5. If 2 players run the same die value, they both get 1 points. This rule overrules the rules about rolling 3 or 6.\n6. The player who reaches 10 points first, wins the game.\n7. A die is a classic white die which has values from 1 to 6.\n8. The game board has size 50 cm x 50 cm and it has borders that prevent dice to go out. The players roll the die into this board. If a die goes out, the roll is repeated. \n\nExample Output: Return a JSON object with the following structure:\n{\n  \"output\": \"@startuml\n<PlantUML diagram description that defines game mechanics comes here>\nnote right of Player: Rule 7\nnote right of Player: A die is a classic white die with values from 1 to 6\nnote right of Player: Rule 8\nnote right of Player: The game board has size 50 cm x 50 cm.\nnote right of Player: The players roll the dice into the game board.\nnote right of Player: Its borders prevent dice to go out.\n@enduml\"\n}\n\n"
            },
            {
                "role": "user",
                "content": "===== REQUIREMENTS =====\n1. The goal of the game is to complete 33 levels successfully.\n2. The board is 200 pixels wide horizontally and 300 pixels wide vertically.\n3. The bricks and the paddle are rectangular blocks with a width of 20 pixels and height of 10 pixels. The ball has a diameter of 10 pixels.\n4. At the beginning of each level, the ball starts from the top left corner of the board and moves downwards with a straight trajectory at a 45\u00b0 angle and a speed of 5 pixels per second.\n5. At each level, the user moves a paddle in order to hit a ball, making it change its direction upward.\n6. To successfully complete a level, the user needs to break all bricks on the board by hitting them with the ball.\n7. Each brick must be either blue, red, or gold and is sized single or double.\n8. A brick is sized single (20 x 10 pixels) or double (40 x 10 pixels).\n9. Blue bricks are destroyed with one hit, red bricks require two hits, gold bricks require three hits.\n10. The first level gets initialised with 50 blue, single bricks randomly placed on the upper third of the board.\n11. The paddle only moves horizontally on the bottom of the board, controlled by the user by left and right arrow keys. The paddle cannot go outside the board. When each level starts the paddle resets to the center of the bottom border.\n12. The ball direction changes every time the ball hits the paddle or the border of the board (except for the bottom border) or a brick, with the same angle of reflection as the angle of incidence.\n13. Every time the next level starts, the speed of the ball increases by 1 pixel per second.\n14. When the user finishes a level, the next level with a different brick arrangement and increased difficulty begins. Each level adds two red bricks and one gold brick.\n15. The sizes of the new level's bricks (single or double) and the brick arrangement (where in the upper third of the board the bricks will spawn) are randomly generated.\n16. 3 lives are given to a user.\n17. The user loses a life every time the ball falls off the bottom of the board.\n18. When the user loses a life but still has lives remaining, the level restarts. Once the user loses all lives, the game is over.\n19. When a game is over, the user shall decide if they want to play again. If they want to play again, the new game starts from level 1. Otherwise, the game ends."
            }
        ],
        "requirements": [
            1,
            2,
            3,
            4,
            6,
            7,
            8,
            9,
            10,
            12,
            13,
            14,
            17,
            18,
            19
        ],
        "requirements_smelly": [
            5,
            11,
            15,
            16
        ],
        "timestamp": "2025-03-31_103806"
    },
    {
        "name": "only_lexical_smells_01",
        "description": "Tracing with a random number of smells.",
        "group": "snake",
        "game": "snake",
        "code_language": "java",
        "iterations": 3,
        "llm": {
            "type": "GPT",
            "model": "gpt-4o",
            "temperature": 0
        },
        "prompts": [
            {
                "role": "system",
                "content": "You are a helpful assistant that generates a sequence diagram from the given requirements so that I can provide it to Planttext to\nvisualize it.\n\nInput: A list of game requirements. Each requirement will be labeled (e.g., 1., 2., etc.). Your task is to generate a PlantUML sequence diagram that:\n1. Represents the requirements in sequence diagram format.\n2. Includes sticky notes indicating which part of the diagram corresponds to each requirement. Each sticky note must follow this format: `note right of [Actor/Participant]: Rule [Number]`.\n3. You can use alt/end or alt/else/end blocks for conditional branching to visually represent alternative flows. Alt blocks can be nested.\n4. Some requirements may contain extra details (such as UI information, numerical data, component sizes or shapes) that are not directly related to system behavior or game mechanics. Append\nthese extra details as additional notes at the end of the diagram (just before the `@enduml` tag). Use newline with a new note component if there are too much information so that the diagram\ndoes not get too wide. Use the following syntax:\nnote right of <leftmost_participant/actor>: Rule <RuleID>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\n\nOutput: Only the JSON that containes the PlantUML sequence diagram. Do not add any explanations or comments.\n\nExample Input:\n1. The game is played by 2 players.\n2. In each turn, a player rolls a die. Then the other player rolls a die.\n3. The player who rolls a 6 gets 1 point.\n4. The player who rolls a 3 gets 2 points.\n5. If 2 players run the same die value, they both get 1 points. This rule overrules the rules about rolling 3 or 6.\n6. The player who reaches 10 points first, wins the game.\n7. A die is a classic white die which has values from 1 to 6.\n8. The game board has size 50 cm x 50 cm and it has borders that prevent dice to go out. The players roll the die into this board. If a die goes out, the roll is repeated. \n\nExample Output: Return a JSON object with the following structure:\n{\n  \"output\": \"@startuml\n<PlantUML diagram description that defines game mechanics comes here>\nnote right of Player: Rule 7\nnote right of Player: A die is a classic white die with values from 1 to 6\nnote right of Player: Rule 8\nnote right of Player: The game board has size 50 cm x 50 cm.\nnote right of Player: The players roll the dice into the game board.\nnote right of Player: Its borders prevent dice to go out.\n@enduml\"\n}\n\n"
            },
            {
                "role": "user",
                "content": "===== REQUIREMENTS =====\n1. The goal of the game is to grow the length of the snake by making the snake eat food until it fills the entire board.\n2. The snake eats food when it touches the food (namely every time the snake passes over food on the board).\n3. Every time the snake eats a piece of food, its body grows by one block which gets attached to the end of the body.\n4. If the snake touches a board side the game is over.\n5. If the snake touches its own body the game is over.\n6. The game board consists of k x k blocks, where k shall be given as input by the user. Every block, including the food and body blocks of the snake, shall have a size such that there are enough blocks to play the game correctly.\n7. When the game starts, the board is initialised with a snake and a piece of food. The snake is represented as a single green block, positioned at the leftmost and bottommost block of the board. The initial direction shall be up. The piece of food is represented as a single red block placed at a random position on the board.\n8. The snake could be moved by pressing up, down, right, or left on the keyboard.\n9. Every time the snake eats a piece of food, a new piece of food shall be placed at a random position on the board.\n10. Every time the snake eats a piece of food, its speed increases by 1%.\n11. The user can set the difficulty to easy or hard. If the user selects \u201ceasy\u201d, the snake initially moves with a speed of 0.5 blocks per second. If the user selects \u201chard\u201d, the snake initially moves with a speed of 2 blocks per second.\n12. After the snake has eaten many pieces of food, a blue bonus piece of food should appear instead of the normal piece of food, at a random position on the board. When the snake eats that piece, three blocks shall be attached to the snake's body.\n13. Sometimes, a golden bonus block shall appear additionally to the food block, at a random position on the board. If the snake eats the bonus block, the speed shall decrease by 5%.\n14. If the user presses p on the keyboard, the game shall pause until the user presses p again."
            }
        ],
        "requirements": [
            1,
            2,
            3,
            4,
            5,
            7,
            9,
            10,
            11,
            14
        ],
        "requirements_smelly": [
            6,
            8,
            12,
            13
        ],
        "timestamp": "2025-03-31_103806"
    },
    {
        "name": "only_semantic_smells_01",
        "description": "Tracing with a random number of smells.",
        "group": "snake",
        "game": "snake",
        "code_language": "java",
        "iterations": 3,
        "llm": {
            "type": "GPT",
            "model": "gpt-4o",
            "temperature": 0
        },
        "prompts": [
            {
                "role": "system",
                "content": "You are a helpful assistant that generates a sequence diagram from the given requirements so that I can provide it to Planttext to\nvisualize it.\n\nInput: A list of game requirements. Each requirement will be labeled (e.g., 1., 2., etc.). Your task is to generate a PlantUML sequence diagram that:\n1. Represents the requirements in sequence diagram format.\n2. Includes sticky notes indicating which part of the diagram corresponds to each requirement. Each sticky note must follow this format: `note right of [Actor/Participant]: Rule [Number]`.\n3. You can use alt/end or alt/else/end blocks for conditional branching to visually represent alternative flows. Alt blocks can be nested.\n4. Some requirements may contain extra details (such as UI information, numerical data, component sizes or shapes) that are not directly related to system behavior or game mechanics. Append\nthese extra details as additional notes at the end of the diagram (just before the `@enduml` tag). Use newline with a new note component if there are too much information so that the diagram\ndoes not get too wide. Use the following syntax:\nnote right of <leftmost_participant/actor>: Rule <RuleID>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\n\nOutput: Only the JSON that containes the PlantUML sequence diagram. Do not add any explanations or comments.\n\nExample Input:\n1. The game is played by 2 players.\n2. In each turn, a player rolls a die. Then the other player rolls a die.\n3. The player who rolls a 6 gets 1 point.\n4. The player who rolls a 3 gets 2 points.\n5. If 2 players run the same die value, they both get 1 points. This rule overrules the rules about rolling 3 or 6.\n6. The player who reaches 10 points first, wins the game.\n7. A die is a classic white die which has values from 1 to 6.\n8. The game board has size 50 cm x 50 cm and it has borders that prevent dice to go out. The players roll the die into this board. If a die goes out, the roll is repeated. \n\nExample Output: Return a JSON object with the following structure:\n{\n  \"output\": \"@startuml\n<PlantUML diagram description that defines game mechanics comes here>\nnote right of Player: Rule 7\nnote right of Player: A die is a classic white die with values from 1 to 6\nnote right of Player: Rule 8\nnote right of Player: The game board has size 50 cm x 50 cm.\nnote right of Player: The players roll the dice into the game board.\nnote right of Player: Its borders prevent dice to go out.\n@enduml\"\n}\n\n"
            },
            {
                "role": "user",
                "content": "===== REQUIREMENTS =====\n1. The goal of the game is to grow the length of the snake by making the snake eat food until it fills the entire board.\n2. The snake eats food when it touches the food (namely every time the snake passes over food on the board).\n3. Every time the snake eats a piece of food, its body grows by one block which gets attached to the end of the body.\n4. If the snake touches a board side the game is over.\n5. If the snake touches its own body the game is over.\n6. The game board consists of k x k blocks, where k shall be given as input by the user. Every block, including the food and body blocks of the snake, shall have a size of 5 x 5 pixels.\n7. When the game starts, the board is initialised with a snake and a piece of food. The snake is represented as a single green block, positioned at the leftmost and bottommost block of the board. The initial direction shall be up. The piece of food is represented as a single red block placed at a random position on the board.\n8. When the user presses up, down, right, or left on the keyboard, the snake continues to move to the corresponding direction.\n9. Every time the snake eats a piece of food,  a new one shall appear.\n10. Every time the snake eats a piece of food, its speed increases by 10 milliseconds.\n11. The user can set the difficulty to easy or hard. If the user selects \u201ceasy\u201d, the snake initially moves with a speed of 0.5 blocks per second.\n12. After the snake has eaten 10 pieces of food, a blue bonus piece of food should appear instead of the normal piece of food, at a random position on the board. When the snake eats that piece, three blocks shall be attached to the snake's body.\n13. Every 5 minutes, a golden bonus block shall appear additionally to the food block, at a random position on the board. If the snake eats the bonus block, the speed shall decrease by 5%.\n14. If the user presses p on the keyboard, the game shall pause until the user presses q again."
            }
        ],
        "requirements": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            12,
            13
        ],
        "requirements_smelly": [
            9,
            10,
            11,
            14
        ],
        "timestamp": "2025-03-31_103806"
    },
    {
        "name": "only_syntactic_smells_01",
        "description": "Tracing with a random number of smells.",
        "group": "snake",
        "game": "snake",
        "code_language": "java",
        "iterations": 3,
        "llm": {
            "type": "GPT",
            "model": "gpt-4o",
            "temperature": 0
        },
        "prompts": [
            {
                "role": "system",
                "content": "You are a helpful assistant that generates a sequence diagram from the given requirements so that I can provide it to Planttext to\nvisualize it.\n\nInput: A list of game requirements. Each requirement will be labeled (e.g., 1., 2., etc.). Your task is to generate a PlantUML sequence diagram that:\n1. Represents the requirements in sequence diagram format.\n2. Includes sticky notes indicating which part of the diagram corresponds to each requirement. Each sticky note must follow this format: `note right of [Actor/Participant]: Rule [Number]`.\n3. You can use alt/end or alt/else/end blocks for conditional branching to visually represent alternative flows. Alt blocks can be nested.\n4. Some requirements may contain extra details (such as UI information, numerical data, component sizes or shapes) that are not directly related to system behavior or game mechanics. Append\nthese extra details as additional notes at the end of the diagram (just before the `@enduml` tag). Use newline with a new note component if there are too much information so that the diagram\ndoes not get too wide. Use the following syntax:\nnote right of <leftmost_participant/actor>: Rule <RuleID>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\nnote right of <leftmost_participant/actor>: <Extra information/detail>\n\nOutput: Only the JSON that containes the PlantUML sequence diagram. Do not add any explanations or comments.\n\nExample Input:\n1. The game is played by 2 players.\n2. In each turn, a player rolls a die. Then the other player rolls a die.\n3. The player who rolls a 6 gets 1 point.\n4. The player who rolls a 3 gets 2 points.\n5. If 2 players run the same die value, they both get 1 points. This rule overrules the rules about rolling 3 or 6.\n6. The player who reaches 10 points first, wins the game.\n7. A die is a classic white die which has values from 1 to 6.\n8. The game board has size 50 cm x 50 cm and it has borders that prevent dice to go out. The players roll the die into this board. If a die goes out, the roll is repeated. \n\nExample Output: Return a JSON object with the following structure:\n{\n  \"output\": \"@startuml\n<PlantUML diagram description that defines game mechanics comes here>\nnote right of Player: Rule 7\nnote right of Player: A die is a classic white die with values from 1 to 6\nnote right of Player: Rule 8\nnote right of Player: The game board has size 50 cm x 50 cm.\nnote right of Player: The players roll the dice into the game board.\nnote right of Player: Its borders prevent dice to go out.\n@enduml\"\n}\n\n"
            },
            {
                "role": "user",
                "content": "===== REQUIREMENTS =====\n1. The goal of the game is to grow the length of the snake by making the snake eat food until it fills the entire board.\n2. The snake eats food when it touches the food (namely every time the snake passes over food on the board).\n3. Every time the snake eats a piece of food, its body grows by one block which gets attached to the end of the body.\n4. The snake must not touch a board side.\n5. The game is over as soon as the snake's body is touched.\n6. The game board consists of k x k blocks, where k shall be given as input by the user. Every block, including the food and body blocks of the snake, shall have a size of 5 x 5 pixels.\n7. When the game starts, the board is initialised with a snake and a piece of food. It shall be represented as a single green block, positioned at the leftmost and bottommost block of the board. The initial direction shall be up. The other is represented as a single red block placed at a random position on the board.\n8. When the user presses up, down, right, or left on the keyboard, the snake continues to move to the corresponding direction.\n9. Every time the snake eats a piece of food, a new piece of food shall be placed at a random position on the board.\n10. Every time the snake eats a piece of food, its speed increases by 1%.\n11. The user can set the difficulty to easy or hard. If the user selects \u201ceasy\u201d, the snake initially moves with a speed of 0.5 blocks per second. If the user selects \u201chard\u201d, the snake initially moves with a speed of 2 blocks per second.\n12. After the snake has eaten 10 pieces of food, a blue bonus piece of food should appear instead of the normal piece of food, at a random position on the board. When the snake eats that piece, three blocks shall be attached to the snake's body.\n13. Every 5 minutes, a golden bonus block shall appear additionally to the food block, at a random position on the board. If the snake eats the bonus block, the speed shall decrease by 5%.\n14. If the user presses p on the keyboard, the game shall pause until the user presses p again."
            }
        ],
        "requirements": [
            1,
            2,
            3,
            6,
            8,
            9,
            10,
            11,
            12,
            13,
            14
        ],
        "requirements_smelly": [
            4,
            5,
            7
        ],
        "timestamp": "2025-03-31_103806"
    }
]